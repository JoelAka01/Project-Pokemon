import { Player } from './player.js';
import { CardModal } from './ui/cardModal.js';
import { GameRenderer } from './ui/gameRenderer.js';
import { DrawTimer } from './ui/drawTimer.js';
import { GameUI } from './ui/gameUI.js';
import { BattleManager } from './battle/battleManager.js';
import { DeckManager } from './deck/deckManager.js';

export class Game {
   constructor(playerDeck, opponentDeck, maxHandSize = 5) {
      // Initialisation des joueurs
      this.player = new Player(playerDeck, maxHandSize);
      this.opponent = new Player(opponentDeck, maxHandSize);
      this.maxHandSize = maxHandSize;

      // Références DOM
      this.playerActive = document.getElementById("player-active");
      this.opponentActive = document.getElementById("opponent-active");
      this.results = document.getElementById("results");
      this.deckContainer = document.getElementById("deck");
      this.handContainer = document.getElementById("hand");
      this.opponentDeckContainer = document.getElementById("opponent-deck");
      this.opponentHandContainer = document.getElementById("opponent-hand");
      this.modal = document.getElementById("card-modal");

      // Initialisation des composants
      this.cardModal = new CardModal(this.modal);
      this.renderer = new GameRenderer();
      this.drawTimer = new DrawTimer();
      this.ui = new GameUI(this);
      this.battleManager = new BattleManager(this, this.results);
      this.deckManager = new DeckManager(this);
   }

   startGame() {
      // Distribuer les cartes initiales
      this.deckManager.dealInitialHands();

      // Rendre l'état initial du jeu
      this.renderGameState();
   }

   renderGameState() {
      // Rendre les decks
      this.renderer.renderDeck(
         this.deckContainer,
         this.player.deck,
         (ev) => this.ui.dragstart_handler(ev)
      );
      this.renderer.renderDeck(this.opponentDeckContainer, this.opponent.deck);

      // Rendre les mains
      this.renderer.renderPlayerHand(
         this.handContainer,
         this.player.hand,
         (card) => this.cardModal.showCardModal(card)
      );
      this.renderer.renderOpponentHand(this.opponentHandContainer, this.opponent.hand);

      // Rendre les cartes actives
      this.renderer.renderActiveCard(this.playerActive, this.player.activeCard);
      this.renderer.renderActiveCard(this.opponentActive, this.opponent.activeCard);
   }

   attemptDrawCard() {
      if (!this.drawTimer.canDrawCard()) {
         this.ui.displayMessage("Attends que le timer expire pour tirer une nouvelle carte !", "warning");
         return null;
      }
      
      // Utiliser le DeckManager pour gérer le tirage
      const result = this.deckManager.attemptDrawCard();
      
      if (!result.success) {
         this.ui.displayMessage(result.message, "warning");
         return null;
      }
      
      // Gestion du timer
      this.drawTimer.disableDrawing();
      this.drawTimer.startDrawTimer();
      
      // Mettre à jour l'affichage
      this.renderGameState();
      
      // Afficher un message de succès
      this.ui.displayMessage(result.message, "success");
      
      return result.card;
   }

   // Pour le drag and drop direct depuis le deck
   attemptDirectDraw() {
      const drawnCard = this.attemptDrawCard();
      if (drawnCard && this.player.activeCard === null) {
         // Utiliser la dernière carte tirée comme carte active
         const lastCardIndex = this.player.hand.cards.length - 1;
         this.playCardFromHand(lastCardIndex);
      }
   }

   playCardFromHand(cardIndex) {
      // Utiliser le DeckManager pour jouer une carte
      const result = this.deckManager.playCardFromHand(cardIndex);
      
      if (!result.success) {
         this.ui.displayMessage(result.message, "warning");
         return;
      }
      
      // Mettre à jour l'affichage
      this.renderGameState();
      
      // Simuler une carte de l'adversaire si besoin
      if (!this.opponent.activeCard && this.opponent.hand.cards.length > 0) {
         this.deckManager.playOpponentCard().then(() => {
            this.renderGameState();
         });
      }
   }

   playerAttack(attackIndex) {
      // Utiliser le BattleManager pour gérer l'attaque
      const result = this.battleManager.playerAttack(attackIndex);
      
      // Afficher un message selon le résultat
      if (!result.success) {
         this.ui.displayMessage(result.message, "error");
         return;
      }
      
      // Afficher le résultat de l'attaque
      this.ui.displayMessage(result.message, "success");
      
      // Mettre à jour l'affichage après le combat
      this.renderGameState();
   }
}
